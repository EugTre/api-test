"""Composition handlers provide various classes that able to convert
JSON nodes of specifc structure into specific values (e.g. value by reference,
generated value, etc.)"""
import json
import copy
from typing import Any
from abc import ABC, abstractmethod

from utils.json_content.json_wrapper import JsonWrapper
from utils.json_content.pointer import Pointer
from utils.data_reader import DataReader
from utils.matchers import MatchersManager, matchers_manager
from utils.generators import GeneratorsManager, generators_manager


class CompositionHandler(ABC):
    """Handler provide logic to convert composition object
    to specific value"""
    DEFINITION_KEY: str = ""

    def match(self, obj: dict) -> bool:
        """Returns True if given dict object is compatible with handler.

        Args:
            obj (dict): dictionary object to check.

        Returns:
            bool: True if object may be handled.
        """
        return self.DEFINITION_KEY in obj

    @abstractmethod
    def compose(self, obj: dict) -> tuple[bool, Any]:
        """Transform object into definite value.

        Args:
            obj (dict): dictionary object to check.

        Returns:
            tuple[bool, Any]: result of processing and composed value.
        """

    @staticmethod
    def _copy_value(value: Any):
        """Makes deepcopy of mutable JSON value (dict or list)

        Args:
            value (Any): value to copy.

        Returns:
            Any: copy (if value is mutable) of value or value
        """
        return copy.deepcopy(value) if isinstance(value, (dict, list)) else value

class ReferenceCompositionHandler(CompositionHandler):
    """Handles reference to JSON node.
    Returns value by JSON Pointer.

    Reference syntax:
    `{"!ref": "/path/to/node"}

    Should be instantiated with `utils.json_content.json_wrapper.JsonWrapper` instance,
    to provide context for reference resolution.
    """
    DEFINITION_KEY = "!ref"

    def __init__(self, content_context: JsonWrapper):
        self.content_context: JsonWrapper = content_context

    def compose(self, obj: dict) -> Any:
        try:
            pointer: Pointer = Pointer.from_string(obj[self.DEFINITION_KEY])
            if pointer.path is None:
                raise ValueError("Referencing to document root is not allowed!")
        except Exception as err:
            err.add_note(f'Error occured on composing Reference Composition {json.dumps(obj)}.')
            raise

        if pointer not in self.content_context:
            return False, None

        value = self.content_context.get(pointer)
        return True, self._copy_value(value)


class FileReferenceCompositionHandler(CompositionHandler):
    """Handles file references.
    Returns JSON content of the file as dict or list.

    File referense composition syntax:
    `{"!file": "path/to/file.ext"}`

    Should be instantiated with `use_cache` bool flag to enable/disable
    file content cache.
    """
    DEFINITION_KEY = "!file"
    CONTEXT = "<file content>{file_path}"

    def __init__(self, use_cache: bool = False):
        self.use_cache = use_cache
        self.cache = {} if use_cache else None

    def compose(self, obj: dict) -> Any:
        path = obj[self.DEFINITION_KEY]
        if self.use_cache and path in self.cache:
            return True, self._copy_value(self.cache[path])

        try:
            content = DataReader.read_json_from_file(path)
        except Exception as err:
            err.add_note('Error occured on composing File '
                         f'Reference Composition {json.dumps(obj)}.')
            raise

        if self.use_cache:
            self.cache[path] = content

        return True, content


class GeneratorCompositionHandler(CompositionHandler):
    """Handles data generation composition.
    Returns generated data.

    Some value will be generated by given generator and args.
    If "!id" is given - same value will be returned for all compositions
    with the same generator name and id.

    All keys except "!gen", "!args" and "!id" will be passed to generator as
    keyword arguments.

    Composition syntax:
    ```
    {
        "!gen": "GeneratorName",
        "!args": [...],
        "!id": "generation_id",
        "keyword_arg1": ...,
        ...
    }
    ```

    Should be instantiated with `utils.generators.GeneratorsManager` instance, containing
    generators collection.
    """
    DEFINITION_KEY = "!gen"
    ARGS_KEY = "!args"
    ID_KEY = "!id"

    def __init__(self, manager: GeneratorsManager) -> None:
        self.manager = manager

    def compose(self, obj: dict) -> tuple[bool, Any]:
        name = obj[self.DEFINITION_KEY]
        args = obj.get(self.ARGS_KEY, tuple())
        kwargs = dict((
            (key, obj[key])
            for key in obj
            if key not in (self.DEFINITION_KEY, self.ARGS_KEY, self.ID_KEY)
        ))
        correlation_id = obj.get(self.ID_KEY, None)

        try:
            value = self.manager.generate(name, args, kwargs, correlation_id)
        except Exception as err:
            err.add_note(f"Error occured on composing Generator Composition {json.dumps(obj)}.")
            raise

        return True, value


class MatcherCompositionHandler(CompositionHandler):
    """Handles matchers compostion.
    Creates and returns matcher.

    Matcher will be instantiated by given name ("!match") and with given args ("!args").

    Other keys except "!match" and "!args" will be passed to matcher as
    keyword arguments.

    Composition syntax:
    ```
    {
        "!match": "MatcherName",
        "!args": [...],
        "keyword_arg1": ...,
        ...
    }
    ```

    Should be instantiated with `utils.matcher.MatchersManager` instance, containing
    matchers collection.
    """
    DEFINITION_KEY = "!match"
    ARGS_KEY = "!args"

    def __init__(self, manager: MatchersManager):
        self.manager = manager

    def compose(self, obj: dict) -> tuple[bool, Any]:
        name = obj[self.DEFINITION_KEY]
        args = obj.get("!args", tuple())
        kwargs = dict((
                            (key, obj[key])
                            for key in obj.keys()
                            if key not in (self.DEFINITION_KEY, self.ARGS_KEY)))

        try:
            matcher = self.manager.get(name, args=args, kwargs=kwargs)
        except Exception as err:
            err.add_note(f"Error occured on composing Matcher Composition {json.dumps(obj)}.")
            raise

        return True, matcher


# Default collection of handlers.
# Keys - classes of the handlers,
# Values - handlers __init__ keyword arguments (**kwargs).
#
# May be updated from anywhere by standard dict methods
DEFAULT_COMPOSITION_HANDLERS_COLLECTION: dict[CompositionHandler, dict[str, Any]] = {
	ReferenceCompositionHandler: {"content_context": None},
    FileReferenceCompositionHandler: {"use_cache": True},
    GeneratorCompositionHandler: {"manager": generators_manager},
    MatcherCompositionHandler: {"manager": matchers_manager}
}
